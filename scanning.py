#!/bin/python

"""
    Autor: Oscar Espinosa C
    Script que provee de las funcionalidades basicas de nmap.
    Utiliza scapy para su ejecucion. De no tener scapy instalado,
        debe instalarse: pip install scapy.all

    !!!!Necesita privilegios de administrador para su ejecucion!!!!
"""

from time import time
import argparse
from scapy.all import *
from sys import exit
from re import match
 

parser = argparse.ArgumentParser()
#Argumento posicional para el script
parser.add_argument("target", help="The host to check its ports")
parser.add_argument("-p", "--port",
    help="The ports to analize, separated by comma")
parser.add_argument("-w","--well_known", action='store_true',
    help="Well known ports (0-1023). No need to add flag --port")
parser.add_argument("-n", "--network_scan", action='store_true',
    help="Scan the network to searching available hosts")
parser.add_argument("-v", "--verbose",action='store_true',
    help="Print the results on terminal")
args = parser.parse_args()


def printOut(output):
    if args.verbose:
        print output

def getPorts(ports_string, well_known):
    try:
        if well_known:
            list_p = range(0, 1024)
        else:
            list_p = [int(x) for x in ports_string.split(',')]
        return list_p
    except ValueError:
        print "Some of the ports given are not int type"
        exit(1)

def is_up(ip):
    """
        Funcion que valida si un host esta arriba enviando un paquete
        ICMP. Devuelve True se esta ariba, False si no se recibe respuesta
        del paquete
    """
    try:
        icmp = IP(dst=ip)/ICMP()
        resp = sr1(icmp, verbose=0, timeout = 1)
        if resp == None:
            return False
        else:
            return True

    except socket.error:
        print "It needs to run with admin permission\n"
        exit (1)


def check_TCP_port(ip,src_port, r_port):
    """
        Funcion que hace la conexion TCP a un puerto especifico.
        Se compara las banderas de la respuesta TCP
        Si esta abierto devuelve True, False en caso contrario
    """
    tcp_connection = sr1(IP(dst=ip)/TCP(sport=src_port,dport=r_port,flags="S"), verbose=0)
    #Se obtienen las banderas de la respuesta TCP del puerto
    if tcp_connection[TCP].flags == "SA":
        return True
    else: #flags = "RA"
        return False
    #ls(ans) para revisar atributos
 
def scan_ports(target, src_port, ports_list):
    """
        Funcion que almacena en una lista todos los puertos abiertos.
        Devuelve una lista con estos puertos abiertos
    """
    open_ports = []
    for port in ports_list:
        if check_TCP_port(args.target, src_port, port):
                open_ports.append(port)
                printOut("port " + str(port) + " is open")

    return open_ports

def is_netmask_ok(netmask):
    """
        Funcion que valida que el argumento dado sea una IP y su mascara, de la siguiente forma:
        XXX.XXX.XXX.XXX/XX
        con X siendo puros numeros
        Retorna una tupla de (IP, submascara) si se hizo match, False en caso contrario
    """
    net = match('^([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3})/([1-2]{1}[0-9]{1})$', netmask)
    if net:
        return (net.group(1), net.group(2))
    else:
        return False

def get_current_IP(splited_ip):
    """
        Incrementa la IP recibida en 1 en la posicion menos significativa
        Cuida que al llegar a 255 cualquiera de las posiciones, se haga el cambio
        debido.
        Devuelve la lista de enteros ya incrementada
    """
    splited_ip[3] += 1
    if splited_ip[3] > 255:
        splited_ip[3] = 0
        splited_ip[2] += 1

    if splited_ip[2] > 255:
        splited_ip[2] = 0
        splited_ip[1] += 1

    if splited_ip[1] > 255:
        splited_ip[1] = 0
        splited_ip[0] += 1

    return splited_ip

def ip2string(splited_ip):
    """
        Funcion que devuelve el string apropiado para la lista de la IP
        fragmentada
    """
    return str(splited_ip[0]) + "." + str(splited_ip[1]) + "." + str(splited_ip[2]) + "." + str(splited_ip[3])

def search_hosts(netmask):
    """
        Funcion que analiza hosts abiertos dentro de una subred
        Devuelve una lista con todos los host abiertos encontrados

        Imprime mensaje de error y termina la ejecucion si el argumento
        no es valido
    """
    open_hosts = []
    net = is_netmask_ok(netmask)
    if net:
        mask = int(net[1])
        splited_ip = [int(x) for x in net[0].split('.')]
        no_hosts = 2**(32 - mask) - 2
        for i in range(1, no_hosts + 1):
            splited_ip = get_current_IP(splited_ip)
            ip = ip2string(splited_ip)
            if is_up(ip):
                printOut("The host " + ip + " is open")
                open_hosts.append(ip)

    else:
        print "The network target is not correct"
        exit(1)

def scanning_p():
    """
        Funcion principal del script
        Si la bandera -n esta activada, se escanea la red, en otro caso,
        se escanean puertos a un host dado.
    """

    if args.network_scan == True:
        open_hosts = search_hosts(args.target)
        #Al final, imprime los hosts solo si no se activo el modo verboso
        if args.verbose == False:
            print "The open hosts are"
            for h in open_hosts:
                print h
    else:
        ports_list = getPorts(args.port, args.well_known)
        printOut("Checking connection")
        if is_up(args.target):
            printOut("The target is up")
            src_port = RandShort()
            printOut("\nChecking port(s)")
            open_ports = scan_ports(args.target, src_port, ports_list)
            if len(open_ports) > 0:
                #Al final, imprime todos los puertos abiertos solo si no se
                #activo el modo verboso
                if args.verbose == False:
                    print "The open port(s) are "
                    for port in open_ports:
                        print port
            else:
                print "No ports are open"
        
        else:
            print "The target is unreacheable"

    exit(0)

if __name__ == '__main__':
    
    start_time = time.time()
    scanning_p()    
    duration = time.time() - start_time
    print "Scannig all ports in " + str(duration) + " sec"
    